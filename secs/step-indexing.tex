\section{A Step-Indexed Logical Relation}

Before diving into the various approaches for constructing a logical
relation without step-indexing, it is well worth the time to see how
a logical relation can be done with it. The purpose of this section is
to sketch the complication intrinsic to any logical relation and show
how step-indexing obliterates them, though at a high cost.

Our logical to begin with a mapping from types to semantic types
(merely sets of terms). In order to handle impredicative polymorphism
Girard's method~\citep{Girard:71,Girard:72}, see \citet{TODO-PFPL} for
a comprehensive explanation of the technique. This means that our
logical relation is of the form
\[
  \den{-}_{-} : \types \to \typesEnv \to \pow{\term \times \term}
\]
The central challenge is of course the meaning of $\den{\cmd{\tau}}$:
the action of the logical relation at commands. At an intuitive level,
for two commands are rather like (partial) functions: they map heaps to heaps
and a return value. Drawing inspiration from how logical relations for
functions are defined, we might write the following for the definition
the logical relation.
\begin{align*}
  \den{\cmd{\tau}}_\eta& \triangleq \{(e_1, e_2) \mid\\
  &\exists m_1, m_2.\ \steps{e_i}{\cmd{m_i}} \land{}\\
  &\forall h_1 \sim h_2.
  \ (m_1, h_1) \simeq (m_2, h_2) \land{}\\
  &\quad \forall v_1, h_1', v_2, h_2'.
  \ (\stepsM{m_1}{h_1}{\ret{v_1}}{h_1'} \land \stepsM{m_2}{h_2}{\ret{v_2}}{h_2'})\\
  &\qquad \implies (h_1' \sim h_2' \land (v_1, v_2) \in \den{\tau}_\eta)
\end{align*}
Here left undefined is the definition of $\sim$ between two
heaps. This is in fact a major issue because there appears to be no
good way to identify when two heaps ought to be equal. The first issue
here is that semantic equality of terms (be it contextual or logical)
is type-indexed. This means that in order to compare heaps pointwise
for equality (a reasonable though still wrong idea) requires that we
at least know the types of the entries. Furthermore, we shouldn't
compare these heaps for equality at all locations necessarily, two
heaps should only need to agree on the cells that the programs are
going to use. This is a significant concept if we want to prove
programs to be equivalent which do not use the heap identically. For
instance, consider the two programs:
\[
  \dcl{\alpha}{1}{\ret{\cmd{\get{\alpha}}}} \qquad\qquad
  \ret{\cmd{\ret{1}}}
\]
These are contextually equivalent (the assignable of the first program
is hidden from external manipulation) and yet they allocate in
different ways. So $\sim$ must not be \emph{merely} pointwise equality
in the most general case. Additionally, proving that these two
programs are equal requires showing that $h_1 ~ h_2$ if and only if
$h_1(\alpha) = 1$. That is, this program doesn't merely require that
heap cells contain values of some syntactic type, but they may need to
belong to an arbitrary semantic type. In order to reconcile these
constraints, one thing is clear: the logical relation must somehow
vary depending on the state that the heap is supposed to be in. It is
simply not the case that programs that are equivalent in a heap where
no cells are required to exist if and only if they're equivalent in a
heap where one cell is required to exist.

The solution to this is called a Kripke logical
relation~\citep{TODO-KRIPKE}. Kripke logical relations, more generally
sheaf models, are a recurring phenomenon in computer
science~\citep{TODO-KRIPKE-STUFF}. The recurring theme of Kripke
logical relations, or sheaf models, is to abandon the notion of a
single global truth and judge truth relative to a current state of the
world. Rather than considering $(e_1, e_2) \in \den{\tau}_\eta$, we
should consider at some world $w$: $(e_1, e_2)
\den{\tau}_\eta(w)$. Now the collection of worlds should be
\emph{ordered} by a reachability relation $\reach$. Importantly,
Kripke logical relations should be monotone in relation to $\reach$:
\[
  \forall w_1, w_2.
  \ w_1 \reach w_2 \land (e_1, e_2) \in \den{\tau}_{w_1}
  \implies (e_1, e_2) \in \den{\tau}_{w_2}
\]
Intuitively, if we know that some fact holds at a world, $w_1$, and we
add more knowledge to $w_1$ to reach $w_2 \breach w_1$ it should not
reduce what we know to be true.

In this case, the choice of Kripke world is meant to be express the
current state of the heap that programs are being compared at, or at
least, what is known about it. What is this world concretely however?
As a first cut, one could consider a simple collection of symbols and
types. That is,
$\worlds \triangleq \powfin{\assignables \times \types}$. We can change
our clause for the logical relation to take these worlds into
account.
\begin{align*}
  \den{\cmd{\tau}}_\eta\different{(w_1)}& \triangleq \{(e_1, e_2) \mid\\
  &\exists m_1, m_2.\ \steps{e_i}{\cmd{m_i}} \land{}\\
  &\forall \different{w_2 \breach w_1}.\ \forall h_1 \different{\sim_{w_2}} h_2.
  \ (m_1, h_1) \simeq (m_2, h_2) \land{}\\
  &\quad \forall v_1, h_1', v_2, h_2'.
  \ (\stepsM{m_1}{h_1}{\ret{v_1}}{h_1'} \land \stepsM{m_2}{h_2}{\ret{v_2}}{h_2'})\\
  &\qquad \implies (\different{\exists w_3 \breach w_2}.
    \ h_1' \different{\sim_{w_3}} h_2' \land (v_1, v_2) \in \den{\tau}_\eta\different{(w_3)})
\end{align*}
This addition of the Kripke worlds is largely forced. We must quantify
over all possible $w_2$ extending $w_1$ at the beginning: if this was
elided then $\den{\cmd{\tau}}_\eta$ would not be monotone. The
extension at the end, $w_3 \breach w_2$, is so that the world may be
updated to reflect the changes that were caused by allocating new
cells or updating existing ones. Still unexplained is
$h_1 \sim_w h_2$. At this point it can be defined in a slightly more
refined way since $w$ at least specifies what cells we ought to
compare for equality. The notion of equality that we want is
problematic though.
\begin{itemize}
\item If some stronger notion of equality than logical equivalence,
  such as $\alpha$-equivalence, is used the fundamental theorem will
  fail in the clause for $\set{\alpha}{e}$.
\item If a weaker equality than logical equivalence is used then the
  fundamental theorem will fail in the clause for $\get{\alpha}$.
\item If logical equivalence itself is used, the definition is will
  become ill-founded. This is because the heap may contain cells with
  a type larger than $\cmd{\tau}$.
\end{itemize}
What is needed is an judo throw in the vein of Girard's
method. Instead of attempting to decide what the equality for a
particular heap location should be in the definition of $\sim_w$, it
should be told to us already by $w$. This idea, originating with
\citet{TODO-PITTS-AND-STARK}, means that our Kripke worlds should
instead satisfy the relation:
\[
  \worlds = \assignables \pto \pow{\term \times \term}
\]
Now the world extension relation is defined by the following.
\[
  w_1 \reach w_2 \triangleq
  \dom(w_1) \subseteq \dom(w_2) \land
  \forall \alpha.\ w_1(\alpha) = w_2(\alpha)
\]
This version is much more plausible. With the definition of the clause
of the logical relation described previously together with the
following definition of $\sim_w$ the logical relation is well-defined.
\[
  h_1 \sim_w h_2 \triangleq \forall \alpha \in \dom(w).
  \  (h_1(\alpha), h_2(\alpha)) \in w(\alpha)
\]
The issue here is more subtle and causes the fundamental theorem to
fail in the rule for allocation: what relation should we pick when a
fresh cell is allocated? It seems that the only choice when allocating
a cell of type $\tau$ at world $w$ is to extend our world with
$\den{\tau}_\eta(w)$. The complication arises when we allocate more
cells later and move to a fresh world. The relation at $\alpha$ is now
stale, it refers to an outdated world and doesn't allow for
equivalences which are true at this new world but were previously
false. To concretely see this, consider the program:
\begin{align*}
  \cmd{
    &\dcl{\alpha}{\lam{x}{\nat}{\cmd{\ret{1}}}}{\\
      &\quad \set{\alpha}{\lam{x}{\nat}{
          \bnd{x}{\cmd{\get{\alpha}}}{\\ & \qquad\qquad\qquad\qquad\ret{x + 1}}
        }}
    }
  }
\end{align*}
This style of program is used to encode recursion in this language in
general. In this case, however, the central point of interest is that
$\alpha$ is updated to contain a command which mentions $\alpha$. In
logical relation, $\alpha$ could only ever contain terms in
$\den{\fn{\nat}{\cmd{\nat}}}(\emptyset)$. In particular, this never
includes a command which mentions $\alpha$. This prevents this
perfectly type safe program from being included in the logical
relation. This will mean that the fundamental theorem fails.

What is to be done here? The root of the issue is that when we
allocate a cell it is impossible to determine precisely what programs
will occupy it because programs in the cell may mention cells that are
yet to be allocated at the time of the construction. What is needed is
for the semantic type stored in a heap cell to vary according to the
world. This fixes an asymmetry between the Kripke world and the
logical relation: the Kripke world supposedly maps locations to
semantic types but the semantics types (as determined by the logical
relation) vary of the Kripke worlds. This leads us to the final form
of the definition of Kripke worlds.
\[
  \worlds = \assignables \pto (\worlds \to \pow{\term \times term})
\]
Herein lies the rub, this definition of the set of worlds is precisely
what is required for this logical relation. It is not a set
though. A simple cardinality argument shows that there can be no such
set since it would have to be larger than its own power set. This is
not an easily avoided problem. It is unknown how to simply avoid this
using ingenuity in the choice of the Kripke world.

This is where step-indexing enters the picture. Step-indexing after
all was introduced to break precisely these sort of circularities and
``solve'' recursive equations up to an approximation.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
