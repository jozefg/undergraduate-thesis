\section{A Logical Relation in $\presheaves{\omega}$ with Syntactic Minimal Invariance}\label{sec:guarded}

The final proposed approach to handling logical relations for state is
to instead study a language which allows us to merely encode
state. This is not sufficient to solve many of the original goals of
this work but it's a simpler problem and a natural stop along the way
to a proper logical relation. The natural candidate for a logical
relation is to consider (guarded) recursive kinds as described by
\citet{TODO-FORK}. The motivation for doing this is that a language
with guarded recursive kinds is quite complex but in a very different
way than a language with state. It does not require Kripke worlds in
particular, the recursion is instead present in the kind structure. By
being present in the structure of types itself it is easier to handle
with type-based methods.

Recursive kinds require us to switch to a richer language where the
types themselves support a form of computation. For our purposes, the
language is given by the following grammar.
\[
  \begin{array}{lcl}
    e & ::= & x \mid \lam{x}{\tau}{e} \mid \ap{e}{e} \mid \Lam{\alpha}{\kappa}{e} \mid \Ap{e}{c}\\
    c, \tau & ::= & \alpha \mid \fn{\tau}{\tau} \mid \all{\alpha}{\kappa}{\tau} \\
      & \mid &  \lam{\alpha}{\kappa}{c} \mid \ap{c}{c} \mid \into{c}
               \mid \out{c}\\
    \kappa & ::= & j \mid \tp \mid \fn{\kappa}{\kappa} \mid \rec{j}{\kappa}
  \end{array}
\]
This language features a simple term language but a much richer type
language, here called \emph{constructors}. Constructors allow for
computation which produces types. This is formally captured by two
judgments: $\hasTJ{\Omega}{\Delta}{c}{\kappa}$ and
$\hasTJ{\Omega}{\Delta}{c_1 \equiv c_2}{\kappa}$. The first judgment
specifies that a constructor $c$ has a kind $\kappa$ in a context of
kind variables $\Omega$ and constructor variables $\Delta$. The second
specifies when two constructors are equal. This latter judgment is
related to the actual expressions of the language by the following
rule.
\[
  \inferrule{
    \hasEJ{\Omega}{\Delta}{\Gamma}{e}{\tau_1}\\
    \hasTJ{\Omega}{\Delta}{\tau_1 \equiv \tau_2}{\tp}
  }{\hasEJ{\Omega}{\Delta}{\Gamma}{e}{\tau_2}}
\]
The constructor language typing judgments are standard for
F$\omega$\citep{TODO-FOMEGA} except for the following rules.
\begin{mathpar}
  \inferrule{
    \hasKJ{\Omega, j}{\kappa}
  }{\hasKJ{\Omega}{\rec{j}{\kappa}}}\and
  \inferrule{
    \hasTJ{\Omega}{\Delta}{c}{\rec{j}{\kappa}}
  }{\hasTJ{\Omega}{\Delta}{\out{c}}{[\rec{j}{\kappa}/j]\kappa}}\and
  \inferrule{
    \hasTJ{\Omega}{\Delta}{c}{\rec{j}{\kappa}}
  }{\hasTJ{\Omega}{\Delta}{\out{c}}{[\rec{j}{\kappa}/j]\kappa}}
\end{mathpar}
The calculus described so far is a version of F$\omega$ with recursive
kinds. This language is quite expressive because recursive kinds allow
for recursive constructor definitions of arbitrary sort through
encoding the Y-combinator at the constructor level. It is
exceptionally poorly behaved, however, because recursive kinds allow
for constructors which do not have a weak head normal form. This
forces choices in the language that seem to have no good answers. For
instance, what terms belong to a constructor of kind $\tp$ that has no
weak head normal form.

There is a technique for potentially approaching a logical relation
for even this language with general recursive types. It draws on two
key ideas, one from Section~\ref{sec:domains} and one from
Section~\ref{sec:smi}. We define a pair of logical relations
$\definitely{-}$ and $\possibly{-}$ as in Section~\ref{sec:smi}. This
logical relation is defined on the \emph{normal forms} of
constructors however. In order to handle the cases where a term has an
infinite normal form or simply diverges, we actually work of finite
fragments of the B\"ohm tree of a term~\citep{TODO-BOHM}. Two terms
are related at a type with an infinite normal form if and only if they
are in all finite approximations of that type. In this case, there is
actually a meaningful difference between $\definitely{-}$ and
$\possibly{-}$: if we reach a node in the B\"ohm tree which indicates
that more information exists but we are not allowed access to it in
this approximation, say ?, $\definitely{?} = \{(\bot, \bot)\}$ while
$\possibly{?} = \term \times \term$.

This approach for logical relations works in that the logical relation
is well-defined and if both sides of the birelation $\eta$ are
well-defined, then $\definitely{\tau}_\eta =
\possibly{\tau}_\eta$. The issue is that this fact does not scale to
general case of $c : \kappa$. In particular, it is not the case that
for an $\eta = \op{\eta}$ that
$\definitely{\lam{\alpha}{\kappa}{c}}_\eta = \possibly{\lam{\alpha}{x}{\kappa}}_\eta$.
The issue is that these must be equal as functions on pairs of
relations $(R_1, R_2)$ and not merely on a single relation $R$. If
$R_1 = R_2$ they are equal but this information is not sufficient to
get the case for $\forall$ to go through in the fundamental
theorem. This failure will be instructive for the coming issue:
$\forall$ is the only case where the higher-typed constructors factor
in to the expression language. This interaction is crucial for
\citet{TODO-POTTIER} so it cannot be ignored, but it will be at the
heart of the failure of the next attempt.

Instead of considering full recursive kinds, we restrict our attention
to a particular class of them: the class of guarded recursive
kinds. Guarded recursion in general originates with
\citet{TODO-NAKANO}. The idea is to isolate which recursive
definitions are \emph{productive}. Productivity is informally the idea
that after a finite number of steps something must be produced by a
program. The program need not compute to a normal form but it should
produce some observable output. The classic example of productivity is
a stream: an infinite stream should never evaluate to a normal form
but we would like to be able to calculate the $n$th element of the
stream in finite time. Productive programming is an extremely natural
paradigm for many programs which are never expected to terminate but
still expected to produce work as they go.

The question is how to ensure that a definition is productive. One
line of work is to consider a syntactic condition on programs. This is
used by some proof assistants~\citep{TODO-COQ} and is simple and
sound. The idea is to check that no recursive calls occur without
being underneath a constructor. In the stream example, for instance,
this means that an element of the stream has to be produced before the
function is entitled to recurse. The issue is that a syntactic check
is too brittle. It does not, for instance, work if a productive
definition has been factored into two different parts since one of
these parts may not be syntactically unguarded. It is also ill-suited
for handling higher-order functions where the productivity may rely on
the supplied function being productive.

A more robust solution is to follow the approach of
\citet{TODO-NAKANO} and equip the type theory with a modality
indicating that something is only available to use ``at a later point
in time''. Then, for instance, in a language with streams the
constructor for a stream would have the type
$\fn{\tau}{\later \mathrm{Stream}_\tau}{\mathrm{Stream}_\tau}$
indicating that it is sufficient to provide the tail of a list so that
it is only available later. In order to make this modality useful,
$\later$ comes equipped with a number of operations. Two of the basic
ones ensure that $\later$ is an applicative functor:
\begin{align*}
  \delay{-} &: \fn{\tau}{\later \tau}\\
  - \zap - &: \later (\fn{\tau_1}{\tau_2}) \to \fn{\later \tau_1}{\later \tau_2}
\end{align*}
Finally, $\later$ can be used to construct fixed points.
\begin{align*}
  \fix{} : \fn{(\fn{\later \tau}{\tau})}{\tau}
\end{align*}
All of this is extremely similar to the operations available in
$\presheaves{\omega}$. The first two operations were facts about the
functor $\later$ and the last one is L\"ob induction. Nakano's work on
guarded recursion provides a syntactic account of this modality. In
the original presentation the operations written above were
presented as subtyping relations in the calculus rendering them all
silent. In more recent presentations~\citep{TODO-GUARDED} these
operations are all made explicit again as they are mediated by
nontrivial isomorphisms. For our purposes, we will continue the
subtyping presentation for consistency with \citet{TODO-POTTIER} which
describes the encoding motivating this construction.

Guarded recursive kinds are slightly different than guarded recursion
in general because the term language contains divergent and
nonproductive terms. The guarantees provided by guardedness apply only
at the level of constructors where it is the case that all
constructors are productive (have a weak head normal form). In this
sense, the language of guarded recursive kinds can be seen as a
particular simply-typed calculus with guarded recursion and a
distinguished base type $\tp$. The term-formers of this type are the
type-formers of our expression language: $\fn{-}{-}$ and
$\all{\alpha}{\kappa}{-}$. A further distinction between this calculus
and other type theories is that our type formers are all
contractive. This means that they take arguments available only later
and produce a result available now. In type theories with a universe,
for instance, the operations on the universe are all nonexpansive:
they preserve laters by taking arguments available later and producing
a result later (the inverse of the $- \zap -$ operation would do this
for instance). This extra strength provided by contractiveness is
exactly what allows for the construction of divergent terms in our
language. This would present a soundness issue for a type theory but
from our perspective it is a natural convenience of a programming
language unconcerned with serving as a logic.

To make this discussion formal, the (selected) rules of our language are the
following.
\begin{mathpar}
  \declareJudgement{\hasKJ{\Omega}{\kappa}}\\
  \inferrule{
    j \in \Omega
  }{\hasKJ{\Omega}{j}} \and
  \inferrule{
    \hasKJ{\Omega}{\kappa} \\
    \hasKJ{\Omega}{\kappa'}
  }{\hasKJ{\Omega}{\fn{\kappa}{\kappa'}}}\and
  \inferrule{
    \hasKJ{\Omega}{\kappa}
  }{\hasKJ{\Omega}{\later \kappa}} \and
  \inferrule{ }
  {\hasKJ{\Omega}{\tp}} \and
  \inferrule{
    \hasKJ{\Omega, j : \kind}{\kappa}\\
    \guardJ{j}{\kappa}
  }{\hasKJ{\Omega}{\rec{j}{\kappa}}}
\end{mathpar}
\begin{mathpar}
  \declareJudgement{\guardJ{j}{\kappa}}\\
  \inferrule{
    \mbox{$j$ not free in $\kappa$}
  }{\guardJ{j}{\kappa}}\and
  \inferrule{
    \guardJ{j}{\kappa_1}\\
    \guardJ{j}{\kappa_2}
  }{\guardJ{j}{\fn{\kappa_1}{\kappa_2}}} \and
  \inferrule{ }{\guardJ{j}{\later \kappa}} \and
  \inferrule{
    \guardJ{j}{\kappa}
  }{\guardJ{j}{(\rec{j'}{\kappa})}}
\end{mathpar}
\begin{mathpar}
  \declareJudgement{\subKJ{}{\kappa}{\kappa'}}\\
  \inferrule{
    \subKJ{}{\kappa_1'}{\kappa_1} \\
    \subKJ{}{\kappa_2}{\kappa_2'}
  }{\subKJ{}{\fn{\kappa_1}{\kappa_2}}{\fn{\kappa_1'}{\kappa_2'}}} \and
  \inferrule{
    \subKJ{}{\kappa}{\kappa'}
  }{\subKJ{}{\later \kappa}{\later \kappa'}} \and
  \inferrule{
  }{\subKJ{}{\kappa}{\later \kappa}} \and
  \inferrule{
  }{\subKJ{}{\later (\fn{\kappa}{\kappa'})}{\fn{\later \kappa}{\later \kappa'}}} \and
  \inferrule{
  }{\subKJ{}{\fn{\later \kappa}{\later \kappa'}}{\later (\fn{\kappa}{\kappa'})}}
\end{mathpar}
\begin{mathpar}
  \declareJudgement{\hasTJ{}{\Delta}{c}{\kappa} \quad \hasEJ{}{\Delta}{\Gamma}{e}{\tau}}\\
  \inferrule{
    \hasTJ{}{\Delta}{\tau_1}{\later \tp}\\
    \hasTJ{}{\Delta}{\tau_2}{\later \tp}
  }{\hasTJ{}{\Delta}{\fn{\tau_1}{\tau_2}}{\tp}}\and
  \inferrule{
    \hasTJ{}{\Delta, \alpha : \kappa}{\tau}{\later \tp}
  }{\hasTJ{}{\Delta}{\all{\alpha}{\kappa}{\tau}}{\tp}}
  \and
  \inferrule{
    \hasTJ{}{\Delta}{\tau}{\later^n\,\tp} \\
    \hasEJ{}{\Delta}{\Gamma, x : \tau}{e}{\tau'}
  }{\hasEJ{}{\Delta}{\Gamma}{\lam{x}{\tau}{e}}{\fn{\tau}{\tau'}}}
  \and
  \inferrule{
    \hasEJ{}{\Delta}{\Gamma}{e}{\forall \alpha : \kappa . \tau}\\
    \hasTJ{}{\Delta}{c}{\later^n \kappa}
  }{\hasEJ{}{\Delta}{\Gamma}{\Ap{e}{c}}{[c / \alpha] \tau}}
\end{mathpar}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
